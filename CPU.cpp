#include "CPU.h"
#include "Cartridge.h"
#include "CartridgeData.h"
#include <iostream>
#include <thread>
#include <ctime>

// Nintendo documents describe the CPU & instructions speed in machine cycles while this document describes them in
// clock cycles. Here is the translation:
//   1 machine cycle = 4 clock cycles
//                   GB CPU Speed    NOP Instruction
// Machine Cycles    1.05MHz         1 cycle
// Clock Cycles      4.19MHz         4 cycles
//
//  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
uint32_t OP_CYCLES[256] = {
    1, 3, 2, 2, 1, 1, 2, 1, 5, 2, 2, 2, 1, 1, 2, 1, // 0
    0, 3, 2, 2, 1, 1, 2, 1, 3, 2, 2, 2, 1, 1, 2, 1, // 1
    2, 3, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1, // 2
    2, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, // 3
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 4
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 5
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 6
    2, 2, 2, 2, 2, 2, 0, 2, 1, 1, 1, 1, 1, 1, 2, 1, // 7
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 8
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 9
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // a
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // b
    2, 3, 3, 4, 3, 4, 2, 4, 2, 4, 3, 0, 3, 6, 2, 4, // c
    2, 3, 3, 0, 3, 4, 2, 4, 2, 4, 3, 0, 3, 0, 2, 4, // d
    3, 3, 2, 0, 0, 4, 2, 4, 4, 1, 4, 0, 0, 0, 2, 4, // e
    3, 3, 2, 1, 0, 4, 2, 4, 3, 2, 4, 1, 0, 0, 2, 4, // f
};

//  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
uint32_t CB_CYCLES[256] = {
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 0
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 1
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 2
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 3
    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 4
    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 5
    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 6
    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 7
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 8
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 9
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // a
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // b
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // c
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // d
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // e
    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // f
};

using namespace std;

uint16_t Register::get_af()
{    
    return ((uint16_t)a << 8) | (uint16_t)f;
}

uint16_t Register::get_bc()
{    
    return ((uint16_t)b << 8) | (uint16_t)c;
}

uint16_t Register::get_de()
{    
    return((uint16_t)d << 8) | (uint16_t)e;
}

uint16_t Register::get_hl()
{    
    return (h << 8) | l;
}

void Register::set_af(uint16_t v)
{        
    a = (uint8_t)(v >> 8);
    f = (uint8_t)(v & 0x00f0);
}

void Register::set_bc(uint16_t v)
{
    b = (uint8_t)(v >> 8);
    c = (uint8_t)(v & 0xff);
}

void Register::set_de(uint16_t v)
{        
    d = (uint8_t)(v >> 8);
    e = (uint8_t)(v & 0x00ff);
}

void Register::set_hl(uint16_t v)
{        
    h = (uint8_t)(v >> 8);
    l = (uint8_t)(v & 0x00ff);
}

static inline uint8_t Flag_og(Flag f)
{
    return (uint8_t)f;
}

static uint8_t Flag_bw(Flag f)
{
    return !Flag_og(f);
}

bool Register::get_flag(Flag fl)
{
    return (f & Flag_og(fl)) != 0;
}

void Register::set_flag(Flag fl, bool v)
{
    if (v)
    {   
        f |= Flag_og(fl);
    } else
    {
        f &= Flag_bw(fl);
    }
}

Register::Register(Term term)
{    
    switch (term)
    {
    case Term_GB:
        a = 0x01;
        break;
    case Term_GBP:
        a = 0xff;
        break;
    case Term_GBC:
        a = 0x11;
        break;
    case Term_SGB:
        a = 0x01;
        break;    
    default:
        break;
    }

    f = 0xb0;
    b = 0x00;
    c = 0x13;
    d = 0x00;
    e = 0xd8;
    h = 0x01;
    l = 0x4d;
    // The GameBoy stack pointer is initialized to 0xfffe on power up but a programmer should not rely on this
    // setting and rather should explicitly set its value.
    sp = 0xfffe;
    // On power up, the GameBoy Program Counter is initialized to 0x0100 and the instruction found at this location
    // in ROM is executed. The Program Counter from this point on is controlled, indirectly, by the program
    // instructions themselves that were generated by the programmer of the ROM cart.
    pc = 0x0100;
}    

uint8_t Cpu::imm()
{    
    uint8_t v = mem->get(reg->pc);
    reg->pc += 1;
    return v;
}

uint16_t Cpu::imm_word()
{
    uint16_t v = mem->get_word(reg->pc);
    reg->pc += 2;
    return v;
}

void Cpu::stack_add(uint16_t v)
{        
    reg->sp -= 2;
    mem->set_word(reg->sp, v);
}

uint16_t Cpu::stack_pop() 
{        
    uint16_t r = mem->get_word(reg->sp);
    reg->sp += 2;
    return r;
}

// Add n to A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Set if carry from bit 3.
// C - Set if carry from bit 7.
void Cpu::alu_add(uint8_t n)
{
    uint8_t a = reg->a;
    uint8_t r = wrapping_add(a, n);
    reg->set_flag(Flag_C, (uint16_t)a + (uint16_t)n > 0xff);
    reg->set_flag(Flag_H, (a & 0x0f) + (n & 0x0f) > 0x0f);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Add n + Carry flag to A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Set if carry from bit 3.
// C - Set if carry from bit 7.
void Cpu::alu_adc(uint8_t n)
{    
    uint8_t a = reg->a;
    uint8_t c = (uint8_t)reg->get_flag(Flag_C);
    uint8_t r = wrapping_add(a, n);
    r = wrapping_add(r, c);
    reg->set_flag(Flag_C, (uint16_t)a + (uint16_t)n + (uint16_t)c > 0xff);
    reg->set_flag(Flag_H, (a & 0x0f) + (n & 0x0f) + (c & 0x0f) > 0x0f);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Subtract n from A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Set.
// H - Set if no borrow from bit 4.
// C - Set if no borrow
void Cpu::alu_sub(uint8_t n) 
{    
    uint8_t a = reg->a;
    uint8_t r = wrapping_sub(a, n);
    reg->set_flag(Flag_C, (uint16_t)a < (uint16_t)n);
    reg->set_flag(Flag_H, (a & 0x0f) < (n & 0x0f));
    reg->set_flag(Flag_N, true);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Subtract n + Carry flag from A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Set.
// H - Set if no borrow from bit 4.
// C - Set if no borrow.
void Cpu::alu_sbc(uint8_t n)
{    
    uint8_t a = reg->a;
    uint8_t c = (uint8_t)reg->get_flag(Flag_C);
    uint8_t r = wrapping_sub(a, n);
    r = wrapping_sub(r, c);
    reg->set_flag(Flag_C, (uint16_t)a < (uint16_t)n + (uint16_t)c);
    reg->set_flag(Flag_H, (a & 0x0f) < (n & 0x0f) + c);
    reg->set_flag(Flag_N, true);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Logically AND n with A, result in A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Set.
// C - Reset
void Cpu::alu_and(uint8_t n)
{
    uint8_t r = reg->a & n;
    reg->set_flag(Flag_C, false);
    reg->set_flag(Flag_H, true);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Logical OR n with register A, result in A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Reset.
void Cpu::alu_or(uint8_t n)
{    
    uint8_t r = reg->a | n;
    reg->set_flag(Flag_C, false);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Logical exclusive OR n with register A, result in A.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Reset.
void Cpu::alu_xor(uint8_t n)
{    
    uint8_t r = reg->a ^ n;
    reg->set_flag(Flag_C, false);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    reg->a = r;
}

// Compare A with n. This is basically an A - n subtraction instruction but the results are thrown away.
// n = A,B,C,D,E,H,L,(HL),#
//
// Flags affected:
// Z - Set if result is zero. (Set if A = n.)
// N - Set.
// H - Set if no borrow from bit 4.
// C - Set for no borrow. (Set if A < n.)
void Cpu::alu_cp(uint8_t n)
{
    uint8_t r = reg->a;
    alu_sub(n);
    reg->a = r;
}

// Increment register n.
// n = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Set if carry from bit 3.
// C - Not affected.
uint8_t Cpu::alu_inc(uint8_t a)
{    
    uint8_t r = wrapping_add(a, 1);
    reg->set_flag(Flag_H, (a & 0x0f) + 0x01 > 0x0f);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Decrement register n.
// n = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if reselt is zero.
// N - Set.
// H - Set if no borrow from bit 4.
// C - Not affected
uint8_t Cpu::alu_dec(uint8_t a)
{    
    uint8_t r = wrapping_sub(a, 1);
    reg->set_flag(Flag_H, trailing_zeros(a) >= 4);
    reg->set_flag(Flag_N, true);
    reg->set_flag(Flag_Z, r == 0);
    return r;
}

// Add n to HL
// n = BC,DE,HL,SP
//
// Flags affected:
// Z - Not affected.
// N - Reset.
// H - Set if carry from bit 11.
// C - Set if carry from bit 15.
void Cpu::alu_add_hl(uint16_t n)
{    
    uint16_t a = reg->get_hl();
    uint16_t r = wrapping_add_16(a, n);
    reg->set_flag(Flag_C, a > 0xffff - n);
    reg->set_flag(Flag_H, (a & 0x0fff) + (n & 0x0fff) > 0x0fff);
    reg->set_flag(Flag_N, false);
    reg->set_hl(r);
}

// Add n to Stack Pointer (SP).
// n = one byte signed immediate value (#).
//
// Flags affected:
// Z - Reset.
// N - Reset.
// H - Set or reset according to operation.
// C - Set or reset according to operation.
void Cpu::alu_add_sp()
{
    uint16_t a = reg->sp;
    uint16_t b = (uint16_t)(int16_t)(int8_t)imm();
    reg->set_flag(Flag_C, (a & 0x00ff) + (b & 0x00ff) > 0x00ff);
    reg->set_flag(Flag_H, (a & 0x000f) + (b & 0x000f) > 0x000f);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, false);
    reg->sp = wrapping_add_16(a, b);
}

// Swap upper & lower nibles of n.
// n = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Reset.
uint8_t Cpu::alu_swap(uint8_t a)
{    
    reg->set_flag(Flag_C, false);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, a == 0x00);
    return (a >> 4) | (a << 4);
}

// Decimal adjust register A. This instruction adjusts register A so that the correct representation of Binary
// Coded Decimal (BCD) is obtained.
//
// Flags affected:
// Z - Set if register A is zero.
// N - Not affected.
// H - Reset.
// C - Set or reset according to operation
void Cpu::alu_daa()
{
    uint8_t a = reg->a;
    uint8_t adjust = reg->get_flag(Flag_C) ? 0x60 : 0x00;
    if (reg->get_flag(Flag_H))
    {
        adjust |= 0x06;
    }

    if (reg->get_flag(Flag_N))
    {
        if (a & 0x0f > 0x09)
        {
            adjust |= 0x06;
        };
        if (a > 0x99)
        {
            adjust |= 0x60;
        }
        a = wrapping_add(a, adjust);
    } else
    {
        a = wrapping_add(a, adjust);
    }
    
    reg->set_flag(Flag_C, adjust >= 0x60);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_Z, a == 0x00);
    reg->a = a;
}

// Complement A register. (Flip all bits.)
//
// Flags affected:
// Z - Not affected.
// N - Set.
// H - Set.
// C - Not affected.
void Cpu::alu_cpl() {    
    reg->a = !reg->a;
    reg->set_flag(Flag_H, true);
    reg->set_flag(Flag_N, true);
}

// Complement carry flag. If C flag is set, then reset it. If C flag is reset, then set it.
// Flags affected:
//
// Z - Not affected.
// N - Reset.
// H - Reset.
// C - Complemented.
void Cpu::alu_ccf() {    
    bool v = !reg->get_flag(Flag_C);
    reg->set_flag(Flag_C, v);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
}

// Set Carry flag.
//
// Flags affected:
// Z - Not affected.
// N - Reset.
// H - Reset.
// C - Set.
void Cpu::alu_scf() {    
    reg->set_flag(Flag_C, true);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
}

// Rotate A left. Old bit 7 to Carry flag.
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 7 data.
uint8_t Cpu::alu_rlc(uint8_t a)
{       
    bool c = (a & 0x80) >> 7 == 0x01;
    uint8_t r = (a << 1) | (uint8_t)c;
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Rotate A left through Carry flag.
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 7 data.
uint8_t Cpu::alu_rl(uint8_t a)
{    
    bool c = (a & 0x80) >> 7 == 0x01;
    uint8_t r = (a << 1) + (uint8_t)reg->get_flag(Flag_C);
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Rotate A right. Old bit 0 to Carry flag.
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 0 data
uint8_t Cpu::alu_rrc(uint8_t a)
{    
    bool c = a & 0x01 == 0x01;
    uint8_t r = c ? (0x80 | (a >> 1)) : (a >> 1);
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Rotate A right through Carry flag.
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 0 data.
uint8_t Cpu::alu_rr(uint8_t a)
{    
    bool c = a & 0x01 == 0x01;
    uint8_t r = reg->get_flag(Flag_C) ? (0x80 | (a >> 1)) : (a >> 1);
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Shift n left into Carry. LSB of n set to 0.
// n = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 7 data
uint8_t Cpu::alu_sla(uint8_t a)
{    
    bool c = (a & 0x80) >> 7 == 0x01;
    uint8_t r = a << 1;
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Shift n right into Carry. MSB doesn't change.
// n = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 0 data.
uint8_t Cpu::alu_sra(uint8_t a)
{    
    bool c = a & 0x01 == 0x01;
    uint8_t r = (a >> 1) | (a & 0x80);
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Shift n right into Carry. MSB set to 0.
// n = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if result is zero.
// N - Reset.
// H - Reset.
// C - Contains old bit 0 data.
uint8_t Cpu::alu_srl(uint8_t a)
{    
    bool c = a & 0x01 == 0x01;
    uint8_t r = a >> 1;
    reg->set_flag(Flag_C, c);
    reg->set_flag(Flag_H, false);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r == 0x00);
    return r;
}

// Test bit b in register r.
// b = 0 - 7, r = A,B,C,D,E,H,L,(HL)
//
// Flags affected:
// Z - Set if bit b of register r is 0.
// N - Reset.
// H - Set.
// C - Not affected
void Cpu::alu_bit(uint8_t a, uint8_t b)
{    
    bool r = a & (1 << b) == 0x00;
    reg->set_flag(Flag_H, true);
    reg->set_flag(Flag_N, false);
    reg->set_flag(Flag_Z, r);    
}

// Set bit b in register r.
// b = 0 - 7, r = A,B,C,D,E,H,L,(HL)
//
// Flags affected:  None.
uint8_t Cpu::alu_set(uint8_t a, uint8_t b)
{
    return a | (1 << b);
}

// Reset bit b in register r.
// b = 0 - 7, r = A,B,C,D,E,H,L,(HL)
//
// Flags affected:  None.
uint8_t Cpu::alu_res(uint8_t a, uint8_t b)
{
    return a & !(1 << b);
}

// Add n to current address and jump to it.
// n = one byte signed immediate value
void Cpu::alu_jr(uint8_t n)
{    
    int8_t v = (int8_t)n;
    reg->pc = (uint16_t)((int32_t)(uint32_t)reg->pc + (int32_t)n);
}

Cpu::Cpu(Term term, Memory *m): mem(m)
{
    reg = new Register(term);
    halted = false;
    ei = true;
}

Cpu::~Cpu()
{
    delete reg;
}

// The IME (interrupt master enable) flag is reset by DI and prohibits all interrupts. It is set by EI and
// acknowledges the interrupt setting by the IE register.
// 1. When an interrupt is generated, the IF flag will be set.
// 2. If the IME flag is set & the corresponding IE flag is set, the following 3 steps are performed.
// 3. Reset the IME flag and prevent all interrupts.
// 4. The PC (program counter) is pushed onto the stack.
// 5. Jump to the starting address of the interrupt.
uint32_t Cpu::hi()
{
    if (!halted && !ei)
    {
        return 0;
    }
    
    uint8_t intf = mem->get(0xff0f);
    uint8_t inte = mem->get(0xffff);
    uint8_t ii = intf & inte;
    if (ii == 0x00)
    {
        return 0;
    }
    
    halted = false;
    if (!ei)
    {
        return 0;
    }
    ei = false;
    
    // Consumer an interrupter, the rest is written back to the register
    uint8_t n = trailing_zeros(ii);
    intf = intf & !(1 << n);
    mem->set(0xff0f, intf);

    stack_add(reg->pc);
    
    // Set the PC to correspond interrupt process program:
    // V-Blank: 0x40
    // LCD: 0x48
    // TIMER: 0x50
    // JOYPAD: 0x60
    // Serial: 0x58
    reg->pc = 0x0040 | ((uint16_t)n << 3);    
    return 4;
}

uint32_t Cpu::ex()
{
    uint8_t opcode = imm();
    uint8_t cbcode = 0;
    
    if (opcode == 0x06)
    {
        reg->b = imm();
    }
    if (opcode == 0x0e)
    {
        reg->c = imm();
    }
    if (opcode == 0x16)
    {
        reg->d = imm();
    }
    if (opcode == 0x1e)
    {
        reg->e = imm();
    }
    if (opcode == 0x26)
    {
        reg->h = imm();
    }
    if (opcode == 0x2e)
    {
        reg->l = imm();
    }
    if (opcode == 0x36)
    {
        uint16_t a = reg->get_hl();
        uint8_t v = imm();
        mem->set(a, v);
    }
    if (opcode == 0x3e)
    {
        reg->a = imm();
    }
    
    // LD (r16), A
    if (opcode == 0x02)
    {
        mem->set(reg->get_bc(), reg->a);        
    }
    if (opcode == 0x12)
    {        
        mem->set(reg->get_de(), reg->a);
    }

    // LD A, (r16)
    if (opcode == 0x0a)
    {
        reg->a = mem->get(reg->get_bc());        
    }
    if (opcode == 0x1a)
    {        
        reg->a = mem->get(reg->get_de());
    }

    // LD (HL+), A
    if (opcode == 0x22)
    {        
        uint16_t a = reg->get_hl();
        mem->set(a, reg->a);
        reg->set_hl(a+1);        
    }

    // LD (HL-), A
    if (opcode == 0x32)
    {        
        uint16_t a = reg->get_hl();
        mem->set(a, reg->a);
        reg->set_hl(a-1);        
    }

    // LD A, (HL+)
    if (opcode == 0x2a)
    {        
        uint16_t v = reg->get_hl();
        reg->a = mem->get(v);
        reg->set_hl(v+1);
    }

    // LD A, (HL-)
    if (opcode == 0x2a)
    {        
        uint16_t v = reg->get_hl();
        reg->a = mem->get(v);
        reg->set_hl(v-1);
    }
        
    // LD r8, r8
    if (opcode == 0x40)
    {        
    }
    if (opcode == 0x41)
    {        
        reg->b = reg->c;
    }
    if (opcode == 0x42)
    {
        reg->b = reg->d;
    }
    if (opcode == 0x43)
    {
        reg->b = reg->e;
    }
    if (opcode == 0x44)
    {
        reg->b = reg->h;
    }
    if (opcode == 0x45)
    {
        reg->b = reg->l;
    }
    if (opcode == 0x46)
    {        
        reg->b = mem->get(reg->get_hl());
    }
    if (opcode == 0x47)
    {
        reg->b = reg->a;
    }
    if (opcode == 0x48)
    {
        reg->c = reg->b;
    }
    if (opcode == 0x49)
    {        
    }
    if (opcode == 0x4a)
    {
        reg->c = reg->d;
    }
    if (opcode == 0x4b)
    {
        reg->c = reg->e;
    }
    if (opcode == 0x4c)
    {
        reg->c = reg->h;
    }
    if (opcode == 0x4d)
    {
        reg->c = reg->l;
    }
    if (opcode == 0x4e)
    {
        reg->c = mem->get(reg->get_hl());
    }
    if (opcode == 0x4f)
    {
        reg->c = reg->a;
    }
    if (opcode == 0x50)
    {
        reg->d = reg->b;
    }
    if (opcode == 0x51)
    {
        reg->d = reg->c;
    }
    if (opcode == 0x52)
    {        
    }
    if (opcode == 0x53)
    {
        reg->d = reg->e;
    }
    if (opcode == 0x54)
    {
        reg->d = reg->h;
    }
    if (opcode == 0x55)
    {
        reg->d = reg->l;
    }
    if (opcode == 0x56)
    {
        reg->d = mem->get(reg->get_hl());
    }
    if (opcode == 0x57)
    {
        reg->d = reg->a;
    }
    if (opcode == 0x58)
    {
        reg->e = reg->b;
    }
    if (opcode == 0x59)
    {
        reg->e = reg->c;
    }
    if (opcode == 0x5a ) {  reg->e = reg->d; }
    if (opcode == 0x5b ) {}
    if (opcode == 0x5c ) {  reg->e = reg->h; }
    if (opcode == 0x5d ) {  reg->e = reg->l; }
    if (opcode == 0x5e ) {  reg->e = mem->get(reg->get_hl()); }
    if (opcode == 0x5f ) {  reg->e = reg->a; }
    if (opcode == 0x60 ) {  reg->h = reg->b; }
    if (opcode == 0x61 ) {  reg->h = reg->c; }
    if (opcode == 0x62 ) {  reg->h = reg->d; }
    if (opcode == 0x63 ) {  reg->h = reg->e; }
    if (opcode == 0x64 ) {}
    if (opcode == 0x65 ) {  reg->h = reg->l; }
    if (opcode == 0x66 ) {  reg->h = mem->get(reg->get_hl()); }
    if (opcode == 0x67 ) {  reg->h = reg->a; }
    if (opcode == 0x68 ) {  reg->l = reg->b; }
    if (opcode == 0x69 ) {  reg->l = reg->c; }
    if (opcode == 0x6a ) {  reg->l = reg->d; }
    if (opcode == 0x6b ) {  reg->l = reg->e; }
    if (opcode == 0x6c ) {  reg->l = reg->h; }
    if (opcode == 0x6d ) {}
    if (opcode == 0x6e ) {  reg->l = mem->get(reg->get_hl()); }
    if (opcode == 0x6f ) {  reg->l = reg->a; }
    if (opcode == 0x70 ) {  mem->set(reg->get_hl(), reg->b); }
    if (opcode == 0x71 ) {  mem->set(reg->get_hl(), reg->c); }
    if (opcode == 0x72 ) {  mem->set(reg->get_hl(), reg->d); }
    if (opcode == 0x73 ) {  mem->set(reg->get_hl(), reg->e); }
    if (opcode == 0x74 ) {  mem->set(reg->get_hl(), reg->h); }
    if (opcode == 0x75 ) {  mem->set(reg->get_hl(), reg->l); }
    if (opcode == 0x77 ) {  mem->set(reg->get_hl(), reg->a); }
    if (opcode == 0x78 ) {  reg->a = reg->b; }
    if (opcode == 0x79 ) {  reg->a = reg->c; }
    if (opcode == 0x7a ) {  reg->a = reg->d; }
    if (opcode == 0x7b ) {  reg->a = reg->e; }
    if (opcode == 0x7c ) {  reg->a = reg->h; }
    if (opcode == 0x7d ) {  reg->a = reg->l; }
    if (opcode == 0x7e ) {  reg->a = mem->get(reg->get_hl()); }
    if (opcode == 0x7f ) {}
        

    // LDH (a8), A        
    if (opcode == 0xe0)
    {
        uint16_t a = 0xff00 | (uint16_t)imm();
        mem->set(a, reg->a);
    }
    
    // LDH A, (a8)
    if (opcode == 0xf0)
    {
        uint16_t a = 0xff00 | (uint16_t)imm();
        reg->a = mem->get(a);
    }
        
    // LD (C), A        
    if (opcode == 0xe2)
    {
        mem->set((0xff00 | (uint16_t)reg->c), reg->a);
    }
    
    // LD A, (C)        
    if (opcode == 0xf2) { reg->a = mem->get(0xff00 | (uint16_t)reg->c); }

    // LD (a16), A
    if (opcode == (0xea )) {
        uint16_t a = imm_word();
        mem->set(a, reg->a);
    }
    // LD A, (a16)
    if (opcode == (0xfa )) {
        uint16_t a = imm_word();
        reg->a = mem->get(a);
    }

    // LD r16, d16
    if (opcode == (0x01 | 0x11 | 0x21 | 0x31 )) {
        uint16_t v = imm_word();        
        if (opcode == 0x01 ) reg->set_bc(v);
        if (opcode == 0x11 ) reg->set_de(v);
        if (opcode == 0x21 ) reg->set_hl(v);
        if (opcode == 0x31 ) reg->sp = v;        
    }

    // LD SP, HL
    if (opcode == 0xf9 ) reg->sp = reg->get_hl();
    // LD SP, d8
    if (opcode == (0xf8 )) {
        uint16_t a = reg->sp;
        uint16_t b = (uint16_t)(int16_t)(int8_t)imm();
        reg->set_flag(Flag_C, (a & 0x00ff) + (b & 0x00ff) > 0x00ff);
        reg->set_flag(Flag_H, (a & 0x000f) + (b & 0x000f) > 0x000f);
        reg->set_flag(Flag_N, false);
        reg->set_flag(Flag_Z, false);
        reg->set_hl(wrapping_add_16(a, b));
    }
    // LD (d16), SP
    if (opcode == (0x08 )) {
        uint16_t a = imm_word();        
        mem->set_word(a, reg->sp);
    }

    // PUSH
    if (opcode == 0xc5 ) stack_add( reg->get_bc() );
    if (opcode == 0xd5 ) stack_add( reg->get_de() );
    if (opcode == 0xe5 ) stack_add( reg->get_hl() );
    if (opcode == 0xf5 ) stack_add( reg->get_af() );

    // POP
    if (opcode == (0xc1 | 0xf1 | 0xd1 | 0xe1 )) {
        uint16_t v = stack_pop();        
        if (opcode == 0xc1 ) reg->set_bc(v);
        if (opcode == 0xd1 ) reg->set_de(v);
        if (opcode == 0xe1 ) reg->set_hl(v);
        if (opcode == 0xf1 ) reg->set_af(v);    
    }

    // ADD A, r8/d8
    if (opcode == 0x80 ) alu_add( reg->b );
    if (opcode == 0x81 ) alu_add( reg->c );
    if (opcode == 0x82 ) alu_add( reg->d );
    if (opcode == 0x83 ) alu_add( reg->e );
    if (opcode == 0x84 ) alu_add( reg->h );
    if (opcode == 0x85 ) alu_add( reg->l );
    if (opcode == (0x86 )) {
        uint8_t v = mem->get(reg->get_hl());
        alu_add( v );
    }
    if (opcode == 0x87 ) alu_add( reg->a );
    if (opcode == (0xc6 )) {
        uint8_t v = imm();
        alu_add( v );
    }

    // ADC A, r8/d8
    if (opcode == 0x88 ) alu_adc( reg->b );
    if (opcode == 0x89 ) alu_adc( reg->c );
    if (opcode == 0x8a ) alu_adc( reg->d );
    if (opcode == 0x8b ) alu_adc( reg->e );
    if (opcode == 0x8c ) alu_adc( reg->h );
    if (opcode == 0x8d ) alu_adc( reg->l );
    if (opcode == (0x8e )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_adc( a );
    }
    if (opcode == 0x8f ) alu_adc( reg->a );
    if (opcode == (0xce )) {
        uint8_t v = imm();
        alu_adc( v );
    }

    // SUB A, r8/d8
    if (opcode == 0x90 ) alu_sub( reg->b );
    if (opcode == 0x91 ) alu_sub( reg->c );
    if (opcode == 0x92 ) alu_sub( reg->d );
    if (opcode == 0x93 ) alu_sub( reg->e );
    if (opcode == 0x94 ) alu_sub( reg->h );
    if (opcode == 0x95 ) alu_sub( reg->l );
    if (opcode == (0x96 )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_sub( a );
    }
    if (opcode == 0x97 ) alu_sub( reg->a );
    if (opcode == (0xd6 )) {
        uint8_t v = imm();
        alu_sub( v );
    }

    // SBC A, r8/d8
    if (opcode == 0x98 ) alu_sbc( reg->b );
    if (opcode == 0x99 ) alu_sbc( reg->c );
    if (opcode == 0x9a ) alu_sbc( reg->d );
    if (opcode == 0x9b ) alu_sbc( reg->e );
    if (opcode == 0x9c ) alu_sbc( reg->h );
    if (opcode == 0x9d ) alu_sbc( reg->l );
    if (opcode == (0x9e )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_sbc( a );
    }
    if (opcode == 0x9f ) alu_sbc( reg->a );
    if (opcode == (0xde )) {
        uint8_t v = imm();
        alu_sbc( v );
    }

    // AND A, r8/d8
    if (opcode == 0xa0 ) alu_and( reg->b );
    if (opcode == 0xa1 ) alu_and( reg->c );
    if (opcode == 0xa2 ) alu_and( reg->d );
    if (opcode == 0xa3 ) alu_and( reg->e );
    if (opcode == 0xa4 ) alu_and( reg->h );
    if (opcode == 0xa5 ) alu_and( reg->l );
    if (opcode == (0xa6 )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_and( a );
    }
    if (opcode == 0xa7 ) alu_and( reg->a );
    if (opcode == (0xe6 )) {
        uint8_t v = imm();
        alu_and( v );
    }

    // OR A, r8/d8
    if (opcode == 0xb0 ) alu_or( reg->b );
    if (opcode == 0xb1 ) alu_or( reg->c );
    if (opcode == 0xb2 ) alu_or( reg->d );
    if (opcode == 0xb3 ) alu_or( reg->e );
    if (opcode == 0xb4 ) alu_or( reg->h );
    if (opcode == 0xb5 ) alu_or( reg->l );
    if (opcode == (0xb6 )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_or( a );
    }
    if (opcode == 0xb7 ) alu_or( reg->a );
    if (opcode == (0xf6 )) {
        uint8_t v = imm();
        alu_or( v );
    }

    // XOR A, r8/d8
    if (opcode == 0xa8 ) alu_xor( reg->b );
    if (opcode == 0xa9 ) alu_xor( reg->c );
    if (opcode == 0xaa ) alu_xor( reg->d );
    if (opcode == 0xab ) alu_xor( reg->e );
    if (opcode == 0xac ) alu_xor( reg->h );
    if (opcode == 0xad ) alu_xor( reg->l );
    if (opcode == (0xae )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_xor( a );
    }
    if (opcode == 0xaf ) alu_xor( reg->a );
    if (opcode == (0xee )) {
        uint8_t v = imm();
        alu_xor( v );
    }

    // CP A, r8/d8
    if (opcode == 0xb8 ) alu_cp( reg->b );
    if (opcode == 0xb9 ) alu_cp( reg->c );
    if (opcode == 0xba ) alu_cp( reg->d );
    if (opcode == 0xbb ) alu_cp( reg->e );
    if (opcode == 0xbc ) alu_cp( reg->h );
    if (opcode == 0xbd ) alu_cp( reg->l );
    if (opcode == (0xbe )) {
        uint8_t a = mem->get(reg->get_hl());
        alu_cp( a );
    }
    if (opcode == 0xbf ) alu_cp( reg->a );
    if (opcode == (0xfe )) {
        uint8_t v = imm();
        alu_cp( v );
    }

    // INC r8
    if (opcode == 0x04 ) reg->b = alu_inc( reg->b );
    if (opcode == 0x0c ) reg->c = alu_inc( reg->c );
    if (opcode == 0x14 ) reg->d = alu_inc( reg->d );
    if (opcode == 0x1c ) reg->e = alu_inc( reg->e );
    if (opcode == 0x24 ) reg->h = alu_inc( reg->h );
    if (opcode == 0x2c ) reg->l = alu_inc( reg->l );
    if (opcode == (0x34 )) {
        uint16_t a = reg->get_hl();
        uint8_t v = mem->get(a);
        uint8_t h = alu_inc( v );
        mem->set(a, h);
    }
    if (opcode == 0x3c ) reg->a = alu_inc( reg->a );

    // DEC r8
    if (opcode == 0x05 ) reg->b = alu_dec( reg->b );
    if (opcode == 0x0d ) reg->c = alu_dec( reg->c );
    if (opcode == 0x15 ) reg->d = alu_dec( reg->d );
    if (opcode == 0x1d ) reg->e = alu_dec( reg->e );
    if (opcode == 0x25 ) reg->h = alu_dec( reg->h );
    if (opcode == 0x2d ) reg->l = alu_dec( reg->l );
    if (opcode == (0x35 )) {
        uint16_t a = reg->get_hl();
        uint8_t v = mem->get(a);
        uint8_t h = alu_dec( v );
        mem->set(a, h);
    }
    if (opcode == 0x3d ) reg->a = alu_dec( reg->a );

    // ADD HL, r16
    if (opcode == 0x09 ) alu_add_hl( reg->get_bc() );
    if (opcode == 0x19 ) alu_add_hl( reg->get_de() );
    if (opcode == 0x29 ) alu_add_hl( reg->get_hl() );
    if (opcode == 0x39 ) alu_add_hl( reg->sp );

    // ADD SP, d8
    if (opcode == 0xe8 ) alu_add_sp();

    // INC r16
    if (opcode == (0x03 )) {
        uint16_t v = wrapping_add_16(reg->get_bc(), 1);
        reg->set_bc(v);
    }
    if (opcode == (0x13 )) {
        uint16_t v = wrapping_add_16(reg->get_de(), 1);
        reg->set_de(v);
    }
    if (opcode == (0x23 )) {
        uint16_t v = wrapping_add_16(reg->get_hl(), 1);
        reg->set_hl(v);
    }
    if (opcode == (0x33 )) {
        uint16_t v = wrapping_add_16(reg->sp, 1);
        reg->sp = v;
    }

    // DEC r16
    if (opcode == (0x0b )) {        
        uint16_t v = wrapping_sub_16(reg->get_bc(), 1);
        reg->set_bc(v);
    }
    if (opcode == (0x1b )) {
        uint16_t v = wrapping_sub_16(reg->get_de(), 1);
        reg->set_de(v);
    }
    if (opcode == (0x2b )) {
        uint16_t v = wrapping_sub_16(reg->get_hl(), 1);
        reg->set_hl(v);
    }
    if (opcode == (0x3b )) {
        uint16_t v = wrapping_sub_16(reg->sp, 1);        
        reg->sp = v;
    }

    // DAA
    if (opcode == 0x27 ) alu_daa();

    // CPL
    if (opcode == 0x2f ) alu_cpl();

    // CCF
    if (opcode == 0x3f ) alu_ccf();

    // SCF
    if (opcode == 0x37 ) alu_scf();

    // NOP
    if (opcode == (0x00 )) {}

    // HALT
    if (opcode == 0x76 ) halted = true;

    // STOP
    if (opcode == (0x10 )) {}

    // DI/EI
    if (opcode == 0xf3 ) ei = false;
    if (opcode == 0xfb ) ei = true;

    // RLCA
    if (opcode == (0x07 )) {
        reg->a = alu_rlc( reg->a );
        reg->set_flag(Flag_Z, false);
    }

    // RLA
    if (opcode == (0x17 )) {
        reg->a = alu_rl( reg->a );
        reg->set_flag(Flag_Z, false);
    }

    // RRCA
    if (opcode == (0x0f )) {
        reg->a = alu_rrc( reg->a );
        reg->set_flag(Flag_Z, false);
    }

    // RRA
    if (opcode == (0x1f )) {
        reg->a = alu_rr( reg->a );
        reg->set_flag(Flag_Z, false);
    }

    // JUMP
    if (opcode == 0xc3 ) reg->pc = imm_word();
    if (opcode == 0xe9 ) reg->pc = reg->get_hl();

    // JUMP IF
    if (opcode == (0xc2 | 0xca | 0xd2 | 0xda )) {
        uint16_t pc = imm_word();
        bool cond = false;
        if (opcode == 0xc2 ) cond = !reg->get_flag(Flag_Z);
        if (opcode == 0xca ) cond = reg->get_flag(Flag_Z);
        if (opcode == 0xd2 ) cond = !reg->get_flag(Flag_C);
        if (opcode == 0xda ) cond = reg->get_flag(Flag_C);          
        if (cond) {
            reg->pc = pc;
        }
    }

    // JR
    if (opcode == (0x18 )) {
        uint8_t n = imm();
        alu_jr( n );
    }

    // JR IF
    if (opcode == (0x20 | 0x28 | 0x30 | 0x38 )) {
        bool cond = false;        
        if (opcode == 0x20 ) cond = !reg->get_flag(Flag_Z);
        if (opcode == 0x28 ) cond = reg->get_flag(Flag_Z);
        if (opcode == 0x30 ) cond = !reg->get_flag(Flag_C);
        if (opcode == 0x38 ) cond = reg->get_flag(Flag_C);
    
        uint8_t n = imm();
        if (cond) {
            alu_jr( n );
        }
    }

    // CALL
    if (opcode == (0xcd )) {
        uint16_t nn = imm_word();
        stack_add( reg->pc );
        reg->pc = nn;
    }

    // CALL IF
    if (opcode == (0xc4 | 0xcc | 0xd4 | 0xdc )) {
        bool cond = false;        
        if (opcode == 0xc4 ) cond = !reg->get_flag(Flag_Z);
        if (opcode == 0xcc ) cond = reg->get_flag(Flag_Z);
        if (opcode == 0xd4 ) cond = !reg->get_flag(Flag_C);
        if (opcode == 0xdc ) cond = reg->get_flag(Flag_C);    
        uint16_t nn = imm_word();
        if (cond) {
            stack_add( reg->pc );
            reg->pc = nn;
        }
    }

    // RST
    if (opcode == (0xc7 )) {
        stack_add( reg->pc );
        reg->pc = 0x00;
    }
    if (opcode == (0xcf )) {
        stack_add( reg->pc );
        reg->pc = 0x08;
    }
    if (opcode == (0xd7 )) {
        stack_add( reg->pc );
        reg->pc = 0x10;
    }
    if (opcode == (0xdf )) {
        stack_add( reg->pc );
        reg->pc = 0x18;
    }
    if (opcode == (0xe7 )) {
        stack_add( reg->pc );
        reg->pc = 0x20;
    }
    if (opcode == (0xef )) {
        stack_add( reg->pc );
        reg->pc = 0x28;
    }
    if (opcode == (0xf7 )) {
        stack_add( reg->pc );
        reg->pc = 0x30;
    }
    if (opcode == (0xff )) {
        stack_add( reg->pc );
        reg->pc = 0x38;
    }

    // RET
    if (opcode == 0xc9 ) reg->pc = stack_pop();

    // RET IF
    if (opcode == (0xc0 | 0xc8 | 0xd0 | 0xd8 )) {
        bool cond = false;        
        if (opcode == 0xc0 ) bool cond = !reg->get_flag(Flag_Z);
        if (opcode == 0xc8 ) bool cond = reg->get_flag(Flag_Z);
        if (opcode == 0xd0 ) bool cond = !reg->get_flag(Flag_C);
        if (opcode == 0xd8 ) bool cond = reg->get_flag(Flag_C);    
        if (cond) {
            reg->pc = stack_pop();
        }
    }

    // RETI
    if (opcode == (0xd9 )) {
        reg->pc = stack_pop();
        ei = true;
    }

    // Extended Bit Operations
    if (opcode == 0xcb) {
        cbcode = mem->get(reg->pc);
        reg->pc += 1;
        
        switch (cbcode) {
                // RLC r8
                case 0x00: reg->b = alu_rlc(reg->b); break;
                case 0x01: reg->c = alu_rlc(reg->c); break;
                case 0x02: reg->d = alu_rlc(reg->d); break;
                case 0x03: reg->e = alu_rlc(reg->e); break;
                case 0x04: reg->h = alu_rlc(reg->h); break;
                case 0x05: reg->l = alu_rlc(reg->l); break;
                case 0x06: {
                    uint16_t a = reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h = alu_rlc(v);
                    mem->set(a, h);
                }
                break;
                case 0x07: reg->a = alu_rlc(reg->a); break;

                // RRC r8
                case 0x08: reg->b = alu_rrc(reg->b); break;
                case 0x09: reg->c = alu_rrc(reg->c); break;
                case 0x0a: reg->d = alu_rrc(reg->d); break;
                case 0x0b: reg->e = alu_rrc(reg->e); break;
                case 0x0c: reg->h = alu_rrc(reg->h); break;
                case 0x0d: reg->l = alu_rrc(reg->l); break;
                case 0x0e: {
                    uint16_t a = reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h = alu_rrc(v);
                    mem->set(a, h);
                }
                break;
                case 0x0f: reg->a = alu_rrc(reg->a); break;

                // RL r8
                case 0x10: reg->b = alu_rl(reg->b); break;
                case 0x11: reg->c = alu_rl(reg->c); break;
                case 0x12: reg->d = alu_rl(reg->d); break;
                case 0x13: reg->e = alu_rl(reg->e); break;
                case 0x14: reg->h = alu_rl(reg->h); break;
                case 0x15: reg->l = alu_rl(reg->l); break;
                case 0x16: {
                    uint16_t a = reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h = alu_rl(v);
                    mem->set(a, h);
                }
                break;
                case 0x17: reg->a = alu_rl(reg->a); break;

                // RR r8
                case 0x18: reg->b = alu_rr(reg->b); break;
                case 0x19: reg->c = alu_rr(reg->c); break;
                case 0x1a: reg->d = alu_rr(reg->d); break;
                case 0x1b: reg->e = alu_rr(reg->e); break;
                case 0x1c: reg->h = alu_rr(reg->h); break;
                case 0x1d: reg->l = alu_rr(reg->l); break;
                case 0x1e: {
                    uint16_t a = reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_rr(v);
                    mem->set(a, h);
                }
                break;
                case 0x1f: reg->a = alu_rr(reg->a); break;

                // SLA r8
                case 0x20: reg->b = alu_sla(reg->b); break;
                case 0x21: reg->c = alu_sla(reg->c); break;
                case 0x22: reg->d = alu_sla(reg->d); break;
                case 0x23: reg->e = alu_sla(reg->e); break;
                case 0x24: reg->h = alu_sla(reg->h); break;
                case 0x25: reg->l = alu_sla(reg->l); break;
                case 0x26: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_sla(v);
                    mem->set(a, h);
                }
                break;
                case 0x27: reg->a = alu_sla(reg->a); break;

                // SRA r8
                case 0x28: reg->b = alu_sra(reg->b); break;
                case 0x29: reg->c = alu_sra(reg->c); break;
                case 0x2a: reg->d = alu_sra(reg->d); break;
                case 0x2b: reg->e = alu_sra(reg->e); break;
                case 0x2c: reg->h = alu_sra(reg->h); break;
                case 0x2d: reg->l = alu_sra(reg->l); break;
                case 0x2e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h = alu_sra(v);
                    mem->set(a, h);
                }
                break;
                case 0x2f: reg->a = alu_sra(reg->a); break;

                // SWAP r8
                case 0x30: reg->b = alu_swap(reg->b); break;
                case 0x31: reg->c = alu_swap(reg->c); break;
                case 0x32: reg->d = alu_swap(reg->d); break;
                case 0x33: reg->e = alu_swap(reg->e); break;
                case 0x34: reg->h = alu_swap(reg->h); break;
                case 0x35: reg->l = alu_swap(reg->l); break;
                case 0x36: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_swap(v);
                    mem->set(a, h);
                }
                break;
                case 0x37: reg->a = alu_swap(reg->a); break;

                // SRL r8
                case 0x38: reg->b = alu_srl(reg->b); break;
                case 0x39: reg->c = alu_srl(reg->c); break;
                case 0x3a: reg->d = alu_srl(reg->d); break;
                case 0x3b: reg->e = alu_srl(reg->e); break;
                case 0x3c: reg->h = alu_srl(reg->h); break;
                case 0x3d: reg->l = alu_srl(reg->l); break;
                case 0x3e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_srl(v);
                    mem->set(a, h);
                }
                break;
                case 0x3f: reg->a = alu_srl(reg->a); break;

                // BIT b, r8
                case 0x40: alu_bit(reg->b, 0); break;
                case 0x41: alu_bit(reg->c, 0); break;
                case 0x42: alu_bit(reg->d, 0); break;
                case 0x43: alu_bit(reg->e, 0); break;
                case 0x44: alu_bit(reg->h, 0); break;
                case 0x45: alu_bit(reg->l, 0); break;
                case 0x46: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 0);
                }
                break;
                case 0x47: alu_bit(reg->a, 0); break;
                case 0x48: alu_bit(reg->b, 1); break;
                case 0x49: alu_bit(reg->c, 1); break;
                case 0x4a: alu_bit(reg->d, 1); break;
                case 0x4b: alu_bit(reg->e, 1); break;
                case 0x4c: alu_bit(reg->h, 1); break;
                case 0x4d: alu_bit(reg->l, 1); break;
                case 0x4e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 1);
                }
                break;
                case 0x4f: alu_bit(reg->a, 1); break;
                case 0x50: alu_bit(reg->b, 2); break;
                case 0x51: alu_bit(reg->c, 2); break;
                case 0x52: alu_bit(reg->d, 2); break;
                case 0x53: alu_bit(reg->e, 2); break;
                case 0x54: alu_bit(reg->h, 2); break;
                case 0x55: alu_bit(reg->l, 2); break;
                case 0x56: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 2);
                }
                break;
                case 0x57: alu_bit(reg->a, 2); break;
                case 0x58: alu_bit(reg->b, 3); break;
                case 0x59: alu_bit(reg->c, 3); break;
                case 0x5a: alu_bit(reg->d, 3); break;
                case 0x5b: alu_bit(reg->e, 3); break;
                case 0x5c: alu_bit(reg->h, 3); break;
                case 0x5d: alu_bit(reg->l, 3); break;
                case 0x5e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 3);
                }
                break;
                case 0x5f: alu_bit(reg->a, 3); break;
                case 0x60: alu_bit(reg->b, 4); break;
                case 0x61: alu_bit(reg->c, 4); break;
                case 0x62: alu_bit(reg->d, 4); break;
                case 0x63: alu_bit(reg->e, 4); break;
                case 0x64: alu_bit(reg->h, 4); break;
                case 0x65: alu_bit(reg->l, 4); break;
                case 0x66: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 4);
                }
                break;
                case 0x67: alu_bit(reg->a, 4); break;
                case 0x68: alu_bit(reg->b, 5); break;
                case 0x69: alu_bit(reg->c, 5); break;
                case 0x6a: alu_bit(reg->d, 5); break;
                case 0x6b: alu_bit(reg->e, 5); break;
                case 0x6c: alu_bit(reg->h, 5); break;
                case 0x6d: alu_bit(reg->l, 5); break;
                case 0x6e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 5);
                }
                break;
                case 0x6f: alu_bit(reg->a, 5); break;
                case 0x70: alu_bit(reg->b, 6); break;
                case 0x71: alu_bit(reg->c, 6); break;
                case 0x72: alu_bit(reg->d, 6); break;
                case 0x73: alu_bit(reg->e, 6); break;
                case 0x74: alu_bit(reg->h, 6); break;
                case 0x75: alu_bit(reg->l, 6); break;
                case 0x76: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 6);
                }
                break;
                case 0x77: alu_bit(reg->a, 6); break;
                case 0x78: alu_bit(reg->b, 7); break;
                case 0x79: alu_bit(reg->c, 7); break;
                case 0x7a: alu_bit(reg->d, 7); break;
                case 0x7b: alu_bit(reg->e, 7); break;
                case 0x7c: alu_bit(reg->h, 7); break;
                case 0x7d: alu_bit(reg->l, 7); break;
                case 0x7e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    alu_bit(v, 7);
                }
                break;
                case 0x7f: alu_bit(reg->a, 7); break;

                // RES b, r8
                case 0x80: reg->b = alu_res(reg->b, 0); break;
                case 0x81: reg->c = alu_res(reg->c, 0); break;
                case 0x82: reg->d = alu_res(reg->d, 0); break;
                case 0x83: reg->e = alu_res(reg->e, 0); break;
                case 0x84: reg->h = alu_res(reg->h, 0); break;
                case 0x85: reg->l = alu_res(reg->l, 0); break;
                case 0x86: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 0);
                    mem->set(a, h);
                }
                break;
                case 0x87: reg->a = alu_res(reg->a, 0); break;
                case 0x88: reg->b = alu_res(reg->b, 1); break;
                case 0x89: reg->c = alu_res(reg->c, 1); break;
                case 0x8a: reg->d = alu_res(reg->d, 1); break;
                case 0x8b: reg->e = alu_res(reg->e, 1); break;
                case 0x8c: reg->h = alu_res(reg->h, 1); break;
                case 0x8d: reg->l = alu_res(reg->l, 1); break;
                case 0x8e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 1);
                    mem->set(a, h);
                }
                break;
                case 0x8f: reg->a = alu_res(reg->a, 1); break;
                case 0x90: reg->b = alu_res(reg->b, 2); break;
                case 0x91: reg->c = alu_res(reg->c, 2); break;
                case 0x92: reg->d = alu_res(reg->d, 2); break;
                case 0x93: reg->e = alu_res(reg->e, 2); break;
                case 0x94: reg->h = alu_res(reg->h, 2); break;
                case 0x95: reg->l = alu_res(reg->l, 2); break;
                case 0x96: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 2);
                    mem->set(a, h);
                }
                break;
                case 0x97: reg->a = alu_res(reg->a, 2); break;
                case 0x98: reg->b = alu_res(reg->b, 3); break;
                case 0x99: reg->c = alu_res(reg->c, 3); break;
                case 0x9a: reg->d = alu_res(reg->d, 3); break;
                case 0x9b: reg->e = alu_res(reg->e, 3); break;
                case 0x9c: reg->h = alu_res(reg->h, 3); break;
                case 0x9d: reg->l = alu_res(reg->l, 3); break;
                case 0x9e: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 3);
                    mem->set(a, h);
                }
                break;
                case 0x9f: reg->a = alu_res(reg->a, 3); break;
                case 0xa0: reg->b = alu_res(reg->b, 4); break;
                case 0xa1: reg->c = alu_res(reg->c, 4); break;
                case 0xa2: reg->d = alu_res(reg->d, 4); break;
                case 0xa3: reg->e = alu_res(reg->e, 4); break;
                case 0xa4: reg->h = alu_res(reg->h, 4); break;
                case 0xa5: reg->l = alu_res(reg->l, 4); break;
                case 0xa6: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 4);
                    mem->set(a, h);
                }
                break;
                case 0xa7: reg->a = alu_res(reg->a, 4); break;
                case 0xa8: reg->b = alu_res(reg->b, 5); break;
                case 0xa9: reg->c = alu_res(reg->c, 5); break;
                case 0xaa: reg->d = alu_res(reg->d, 5); break;
                case 0xab: reg->e = alu_res(reg->e, 5); break;
                case 0xac: reg->h = alu_res(reg->h, 5); break;
                case 0xad: reg->l = alu_res(reg->l, 5); break;
                case 0xae: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 5);
                    mem->set(a, h);
                }
                break;
                case 0xaf: reg->a = alu_res(reg->a, 5); break;
                case 0xb0: reg->b = alu_res(reg->b, 6); break;
                case 0xb1: reg->c = alu_res(reg->c, 6); break;
                case 0xb2: reg->d = alu_res(reg->d, 6); break;
                case 0xb3: reg->e = alu_res(reg->e, 6); break;
                case 0xb4: reg->h = alu_res(reg->h, 6); break;
                case 0xb5: reg->l = alu_res(reg->l, 6); break;
                case 0xb6: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 6);
                    mem->set(a, h);
                }
                break;
                case 0xb7: reg->a = alu_res(reg->a, 6); break;
                case 0xb8: reg->b = alu_res(reg->b, 7); break;
                case 0xb9: reg->c = alu_res(reg->c, 7); break;
                case 0xba: reg->d = alu_res(reg->d, 7); break;
                case 0xbb: reg->e = alu_res(reg->e, 7); break;
                case 0xbc: reg->h = alu_res(reg->h, 7); break;
                case 0xbd: reg->l = alu_res(reg->l, 7); break;
                case 0xbe: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_res(v, 7);
                    mem->set(a, h);
                }
                break;
                case 0xbf: reg->a = alu_res(reg->a, 7); break;

                // SET b, r8
                case 0xc0: reg->b = alu_set(reg->b, 0); break;
                case 0xc1: reg->c = alu_set(reg->c, 0); break;
                case 0xc2: reg->d = alu_set(reg->d, 0); break;
                case 0xc3: reg->e = alu_set(reg->e, 0); break;
                case 0xc4: reg->h = alu_set(reg->h, 0); break;
                case 0xc5: reg->l = alu_set(reg->l, 0); break;
                case 0xc6: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 0);
                    mem->set(a, h);
                }
                break;
                case 0xc7: reg->a = alu_set(reg->a, 0); break;
                case 0xc8: reg->b = alu_set(reg->b, 1); break;
                case 0xc9: reg->c = alu_set(reg->c, 1); break;
                case 0xca: reg->d = alu_set(reg->d, 1); break;
                case 0xcb: reg->e = alu_set(reg->e, 1); break;
                case 0xcc: reg->h = alu_set(reg->h, 1); break;
                case 0xcd: reg->l = alu_set(reg->l, 1); break;
                case 0xce: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 1);
                    mem->set(a, h);
                }
                break;
                case 0xcf: reg->a = alu_set(reg->a, 1); break;
                case 0xd0: reg->b = alu_set(reg->b, 2); break;
                case 0xd1: reg->c = alu_set(reg->c, 2); break;
                case 0xd2: reg->d = alu_set(reg->d, 2); break;
                case 0xd3: reg->e = alu_set(reg->e, 2); break;
                case 0xd4: reg->h = alu_set(reg->h, 2); break;
                case 0xd5: reg->l = alu_set(reg->l, 2); break;
                case 0xd6: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 2);
                    mem->set(a, h);
                }
                break;
                case 0xd7: reg->a = alu_set(reg->a, 2); break;
                case 0xd8: reg->b = alu_set(reg->b, 3); break;
                case 0xd9: reg->c = alu_set(reg->c, 3); break;
                case 0xda: reg->d = alu_set(reg->d, 3); break;
                case 0xdb: reg->e = alu_set(reg->e, 3); break;
                case 0xdc: reg->h = alu_set(reg->h, 3); break;
                case 0xdd: reg->l = alu_set(reg->l, 3); break;
                case 0xde: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 3);
                    mem->set(a, h);
                }
                break;
                case 0xdf: reg->a = alu_set(reg->a, 3); break;
                case 0xe0: reg->b = alu_set(reg->b, 4); break;
                case 0xe1: reg->c = alu_set(reg->c, 4); break;
                case 0xe2: reg->d = alu_set(reg->d, 4); break;
                case 0xe3: reg->e = alu_set(reg->e, 4); break;
                case 0xe4: reg->h = alu_set(reg->h, 4); break;
                case 0xe5: reg->l = alu_set(reg->l, 4); break;
                case 0xe6: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 4);
                    mem->set(a, h);
                }
                break;
                case 0xe7: reg->a = alu_set(reg->a, 4); break;
                case 0xe8: reg->b = alu_set(reg->b, 5); break;
                case 0xe9: reg->c = alu_set(reg->c, 5); break;
                case 0xea: reg->d = alu_set(reg->d, 5); break;
                case 0xeb: reg->e = alu_set(reg->e, 5); break;
                case 0xec: reg->h = alu_set(reg->h, 5); break;
                case 0xed: reg->l = alu_set(reg->l, 5); break;
                case 0xee: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 5);
                    mem->set(a, h);
                }
                break;
                case 0xef: reg->a = alu_set(reg->a, 5); break;
                case 0xf0: reg->b = alu_set(reg->b, 6); break;
                case 0xf1: reg->c = alu_set(reg->c, 6); break;
                case 0xf2: reg->d = alu_set(reg->d, 6); break;
                case 0xf3: reg->e = alu_set(reg->e, 6); break;
                case 0xf4: reg->h = alu_set(reg->h, 6); break;
                case 0xf5: reg->l = alu_set(reg->l, 6); break;
                case 0xf6: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 6);
                    mem->set(a, h);
                }
                break;
                case 0xf7: reg->a = alu_set(reg->a, 6); break;
                case 0xf8: reg->b = alu_set(reg->b, 7); break;
                case 0xf9: reg->c = alu_set(reg->c, 7); break;
                case 0xfa: reg->d = alu_set(reg->d, 7); break;
                case 0xfb: reg->e = alu_set(reg->e, 7); break;
                case 0xfc: reg->h = alu_set(reg->h, 7); break;
                case 0xfd: reg->l = alu_set(reg->l, 7); break;
                case 0xfe: {
                    uint16_t a =reg->get_hl();
                    uint8_t v = mem->get(a);
                    uint8_t h =alu_set(v, 7);
                    mem->set(a, h);
                }
                break;
                case 0xff: reg->a = alu_set(reg->a, 7); break;
        }
    }

    if (opcode == 0xd3) cout << "Opcode 0xd3 is not implemented" << endl;
    if (opcode == 0xdb) cout << "Opcode 0xdb is not implemented" << endl;
    if (opcode == 0xdd) cout << "Opcode 0xdd is not implemented" << endl;
    if (opcode == 0xe3) cout << "Opcode 0xe3 is not implemented" << endl;
    if (opcode == 0xe4) cout << "Opcode 0xd4 is not implemented" << endl;
    if (opcode == 0xeb) cout << "Opcode 0xeb is not implemented" << endl;
    if (opcode == 0xec) cout << "Opcode 0xec is not implemented" << endl;
    if (opcode == 0xed) cout << "Opcode 0xed is not implemented" << endl;
    if (opcode == 0xf4) cout << "Opcode 0xf4 is not implemented" << endl;
    if (opcode == 0xfc) cout << "Opcode 0xfc is not implemented" << endl;
    if (opcode == 0xfd) cout << "Opcode 0xfd is not implemented" << endl;

    uint8_t ecycle = 0x00;
    if (opcode == (0x20 | 0x30)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x00;
        } else {
            ecycle = 0x01;
        }
    }
    if (opcode == (0x28 | 0x38)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x01;
        } else {
            ecycle = 0x00;
        }
    }
    if (opcode == (0xc0 | 0xd0)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x00;
        } else {
            ecycle = 0x03;
        }
    }
    if (opcode == (0xc8 | 0xcc | 0xd8 | 0xdc)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x03;
        } else {
            ecycle = 0x00;
        }
    }
    if (opcode == (0xc2 | 0xd2)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x00;
        } else {
            ecycle = 0x01;
        }
    }
    if (opcode == (0xca | 0xda)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x01;
        } else {
            ecycle = 0x00;
        }
    }
    if (opcode == (0xc4 | 0xd4)) {
        if (reg->get_flag(Flag_Z)) {
            ecycle = 0x00;
        } else {
            ecycle = 0x03;
        }
    }

    if (opcode == 0xcb) {
        return CB_CYCLES[(size_t)cbcode];
    } else {
        return OP_CYCLES[(size_t)opcode] + ecycle;
    }
}

uint32_t Cpu::next()
{
    uint32_t mac;
    uint32_t c = hi();
    if (c != 0)
    {
        mac = c;
    } else if (halted)
    {
        mac = OP_CYCLES[0];
    } else
    {
        mac = ex();
    }
    
    return mac * 4;    
}

Rtc::Rtc(Term term, Memory *m)
{
    cpu = new Cpu(term, m);
    step_flip = false;
    step_cycles = 0;
    step_zero = chrono::steady_clock::now();
}

Rtc::~Rtc()
{
    delete cpu;
}

uint32_t CLOCK_FREQUENCY = 4194304;
uint32_t STEP_TIME = 16;
uint32_t STEP_CYCLES = (uint32_t)((double)STEP_TIME / (double)(1000.0 / (double)CLOCK_FREQUENCY));

uint64_t saturating_sub(uint64_t x, uint64_t y)
{
    uint64_t res = x - y;
    res &= -(res <= x);

    return res;
}

// Function next simulates real hardware execution speed, by limiting the frequency of the function cpu.next().
uint32_t Rtc::next()
{
    if (step_cycles > STEP_CYCLES)
    {
        step_flip = true;
        step_cycles -= STEP_CYCLES;
        chrono::steady_clock::time_point now = chrono::steady_clock::now();
        uint64_t d = chrono::duration_cast<std::chrono::milliseconds>(now - step_zero).count();
        uint64_t s = saturating_sub(STEP_TIME, d);
        cout << "CPU: sleep " << s << " millis" << endl;

        // sleep
        chrono::duration<int, std::milli> ms(s);
        this_thread::sleep_for(ms);        

        chrono::duration<int, std::milli> st(STEP_TIME);
        step_zero += st;

        // If now is after the just updated target frame time, reset to
        // avoid drift.
        if (now > step_zero)
        {
            step_zero = now;
        }        
    }

    uint32_t cycles = cpu->next();
    step_cycles += cycles;
    return cycles;
}

bool Rtc::flip()
{
    bool r = step_flip;
    if (r)
    {
        step_flip = false;
    }
    return r;    
}